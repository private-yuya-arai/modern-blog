
import os
import re
import hashlib
import matplotlib.pyplot as plt
import glob
import sys
from io import BytesIO

# Configuration
POSTS_DIR = 'src/posts' # Relative path from where script is run (project root)
IMAGES_DIR_REL = 'public/images/generated'
IMAGES_DIR_ABS = os.path.join(os.getcwd(), IMAGES_DIR_REL)
MARKER = '# auto-plot'

def setup_environment():
    """Ensure the output directory exists."""
    os.makedirs(IMAGES_DIR_ABS, exist_ok=True)

def execute_and_save_plot(code, filename_base):
    """Executes python code and saves the current matplotlib figure."""
    # Create a fresh figure to avoid side effects
    plt.close('all')
    
    try:
        # Create a local namespace for execution
        local_env = {}
        exec(code, {}, local_env)
        
        # Check if a plot was created
        if plt.get_fignums():
            # Save the figure
            output_filename = f"{filename_base}.png"
            output_path = os.path.join(IMAGES_DIR_ABS, output_filename)
            plt.savefig(output_path)
            plt.close('all')
            print(f"Generated plot: {output_path}")
            return f"/images/generated/{output_filename}"
        else:
            print("No plot generated by code block.")
            return None
    except Exception as e:
        print(f"Error executing code block: {e}")
        return None

def process_file(filepath):
    """Scans and processes a single markdown file."""
    print(f"Processing {filepath}...")
    with open(filepath, 'r', encoding='utf-8') as f:
        lines = f.readlines()

    new_lines = []
    in_code_block = False
    code_block_lines = []
    code_start_index = -1
    
    i = 0
    while i < len(lines):
        line = lines[i]
        
        if line.strip().startswith('```python'):
            in_code_block = True
            code_block_lines = []
            code_start_index = len(new_lines) # Not used directly but tracked
            new_lines.append(line)
            i += 1
            continue
            
        if in_code_block:
            if line.strip().startswith('```'):
                in_code_block = False
                new_lines.append(line)
                
                # Verify if this block had the marker
                full_code = "".join(code_block_lines)
                if MARKER in full_code:
                    print(f"  Found auto-plot marker in {os.path.basename(filepath)}")
                    
                    # Generate hash and filename
                    code_hash = hashlib.md5(full_code.encode('utf-8')).hexdigest()[:10]
                    file_basename = os.path.basename(filepath).replace('.md', '')
                    image_name = f"{file_basename}_{code_hash}"
                    
                    # Execute code
                    image_url = execute_and_save_plot(full_code, image_name)
                    
                    if image_url:
                        # Prepare the image link line
                        image_markdown = f"![Generated Plot]({image_url})\n"
                        
                        # Check if the NEXT line is already an image link we generated
                        # We look ahead
                        j = i + 1
                        next_line_is_image = False
                        
                        # Skip empty lines to find next content
                        # But for simplicity, let's just look at the immediate next non-empty line?
                        # Or strictly the next line? 
                        # Usually markdown images are on their own line.
                        
                        # Peek at next lines
                        k = i + 1
                        while k < len(lines) and lines[k].strip() == "":
                                k += 1
                        
                        if k < len(lines):
                            next_content = lines[k].strip()
                            # Check if it looks like an image link we generated
                            # stricter check: ![...](/images/generated/...)
                            if re.match(r'!\[.*?\]\(/images/generated/.*?\)', next_content):
                                print(f"  Updating existing image link at line {k+1}")
                                # It is an existing generated image link. We will replace it.
                                # To do this, we need to skip lines from i+1 to k inclusive in the original read 
                                # NO, we act on `new_lines`. 
                                # We just append the NEW image link, and SKIP the old one in the loop.
                                
                                # Logic: We append the new image link.
                                # Then we advance `i` to skip the old link.
                                
                                # Add empty line before image if needed for spacing? Standard is usually separate line.
                                new_lines.append("\n") 
                                new_lines.append(image_markdown)
                                
                                # Now advance i to k (the line with old image)
                                # And we also want to skip the empty lines we scanned?
                                # Yes, effectively we are replacing "whitespace + old image link" with "newline + new image link".
                                i = k # loop increment will trigger next, so i needs to be k. 
                                # Wait, loop does i+=1 at end? No, we control i.
                                # Let's handle i carefully.
                            else:
                                # Next line is NOT a generated image. Insert new one.
                                print(f"  Inserting new image link.")
                                new_lines.append("\n")
                                new_lines.append(image_markdown)
                        else:
                                # End of file
                                print(f"  Appending new image link at EOF.")
                                new_lines.append("\n")
                                new_lines.append(image_markdown)

                i += 1
            else:
                code_block_lines.append(line)
                new_lines.append(line)
                i += 1
        else:
            new_lines.append(line)
            i += 1

    # Write back if changed
    # Join with empty string because lines already have newlines
    final_content = "".join(new_lines)
    
    # Only write if different (avoid touching file mtime if not needed potentially, but simple comparison is fine)
    with open(filepath, 'r', encoding='utf-8') as f:
         if f.read() == final_content:
             print("  No changes to file content.")
             return

    with open(filepath, 'w', encoding='utf-8') as f:
        f.write(final_content)
    print(f"  Updated {filepath}")

def main():
    setup_environment()
    # Assuming script is run from project root
    files = glob.glob(os.path.join(POSTS_DIR, '*.md'))
    if not files:
        print(f"No markdown files found in {POSTS_DIR}")
        return

    for f in files:
        process_file(f)

if __name__ == "__main__":
    main()
